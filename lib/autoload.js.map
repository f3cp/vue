{"version":3,"sources":["autoload.js"],"names":["instance","count","_instance","args","autoload","channels","forEach","channel","callback","_channels","Array","isArray","times","length","ch","history","then","response","messages","m","message","entry","outputOn","push","sort","history_sort_attribute","catch"],"mappings":";;;;;;;;AAAA;;;;;;;;;AAGE,kBAAYA,QAAZ,EAAsB;AAAA;;AACpB,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,SAAL,GAAiBF,QAAjB;AACD;;;;+BAOUG,I,EAAM;AAAA;;AACf,UAAIA,KAAKC,QAAL,IAAiB,OAAOD,KAAKC,QAAZ,KAAyB,QAA9C,EAAwD;AACtD,aAAKH,KAAL,CAAWE,KAAKE,QAAhB,IAA4BF,KAAKC,QAAjC;;AAEAD,aAAKE,QAAL,CAAcC,OAAd,CAAsB,UAACC,OAAD,EAAa;AACjC,gBAAKN,KAAL,CAAWM,OAAX,IAAsBJ,KAAKC,QAA3B;AACD,SAFD;AAGD;AACF;;;+BAQUG,O,EAASC,Q,EAAU;AAAA;;AAC5B,UAAI,KAAKP,KAAL,CAAWM,OAAX,CAAJ,EAAyB;AACvB,YAAIP,WAAW,KAAKA,QAApB;AACA,YAAIS,YAAYC,MAAMC,OAAN,CAAcJ,OAAd,IAAyBA,OAAzB,GAAmC,CAACA,OAAD,CAAnD;AACA,YAAIK,QAAQH,UAAUI,MAAtB;;AAEAJ,kBAAUH,OAAV,CAAkB,UAACQ,EAAD,EAAQ;AACxBd,mBAASe,OAAT,CAAiB,EAAER,SAASO,EAAX,EAAeb,OAAO,OAAKA,KAAL,CAAWM,OAAX,CAAtB,EAAjB,EAA8DS,IAA9D,CAAmE,UAACC,QAAD,EAAc;AAC/EA,qBAASC,QAAT,CAAkBZ,OAAlB,CAA0B,UAACa,CAAD,EAAO;AAC/BA,gBAAEC,OAAF,GAAYD,EAAEE,KAAd;AACAF,gBAAEZ,OAAF,GAAYO,EAAZ;;AAEAd,uBAASsB,QAAT,CAAkBC,IAAlB,CAAuBhB,OAAvB,EAAgCY,CAAhC;AACD,aALD;;AAOAP,qBAAS,CAAT;;AAEA,gBAAIJ,YAAYI,UAAU,CAA1B,EAA6B;AAC3BZ,uBAASsB,QAAT,CAAkBE,IAAlB,CAAuBjB,OAAvB,EAAgC,iBAAOkB,sBAAvC;AACAjB;AACD;AACF,WAdD,EAcGkB,KAdH,CAcS,YAAM,CAAE,CAdjB;AAeD,SAhBD;AAiBD;AACF;;;gCAOWvB,I,EAAM;AAAA;;AAChB,UAAIO,MAAMC,OAAN,CAAcR,KAAKE,QAAnB,CAAJ,EAAkC;AAChCF,aAAKE,QAAL,CAAcC,OAAd,CAAsB,UAACQ,EAAD,EAAQ;AAC5B,cAAI,OAAKb,KAAL,CAAWa,EAAX,CAAJ,EAAoB,OAAO,OAAKb,KAAL,CAAWa,EAAX,CAAP;AACrB,SAFD;AAGD,OAJD,MAIO,IAAI,KAAKb,KAAL,CAAWE,KAAKE,QAAhB,CAAJ,EAA+B;AACpC,eAAO,KAAKJ,KAAL,CAAWE,KAAKE,QAAhB,CAAP;AACD;AACF","file":"autoload.js","sourcesContent":["import config from '../config.json';\n\nexport default class {\n  constructor(instance) {\n    this.count = {};\n    this._instance = instance;\n  }\n\n  /**\n   * Enable the autoload for a channel or a set of channels subscribed\n   *\n   * @param args\n   */\n  enableLoad(args) {\n    if (args.autoload && typeof args.autoload === 'number') {\n      this.count[args.channels] = args.autoload;\n\n      args.channels.forEach((channel) => {\n        this.count[channel] = args.autoload;\n      });\n    }\n  }\n\n  /**\n   * Get history of a channel or a set of channels.\n   *\n   * @param {string|[string]} channel\n   * @param callback\n   */\n  getHistory(channel, callback) {\n    if (this.count[channel]) {\n      let instance = this.instance;\n      let _channels = Array.isArray(channel) ? channel : [channel];\n      let times = _channels.length;\n\n      _channels.forEach((ch) => {\n        instance.history({ channel: ch, count: this.count[channel] }).then((response) => {\n          response.messages.forEach((m) => {\n            m.message = m.entry;\n            m.channel = ch;\n\n            instance.outputOn.push(channel, m);\n          });\n\n          times -= 1;\n\n          if (callback && times === 0) {\n            instance.outputOn.sort(channel, config.history_sort_attribute);\n            callback();\n          }\n        }).catch(() => {});\n      });\n    }\n  }\n\n  /**\n   * Disable the autoload for a channel or set of channels\n   *\n   * @param args\n   */\n  disableLoad(args) {\n    if (Array.isArray(args.channels)) {\n      args.channels.forEach((ch) => {\n        if (this.count[ch]) delete this.count[ch];\n      });\n    } else if (this.count[args.channels]) {\n      delete this.count[args.channels];\n    }\n  }\n}\n"]}